# v3.1 Security & Quality Tasks - Detailed Specifications

**Sprint Theme**: Code Quality & Security Hardening
**Source**: Opus 4.5 Audit Analysis (Jan 21, 2026)
**Status**: Active Development
**Last Updated**: 2026-01-28

---

## Overview

This sprint addresses 6 high-value technical debt items identified in the Opus 4.5 audit. These tasks improve reliability, security, and testability without adding new features.

**Why This Sprint Matters**:
- v3.0 shipped major features (Bootstrap, GitHub Action)
- v3.1 focuses on code quality and security hardening
- Addresses ~50% of remaining audit findings
- Prepares foundation for v3.2+ strategic features

---

## [AUDIT-1] Centralize Error Handling

**Priority**: ðŸ”´ HIGH
**Effort**: 2-3h
**Complexity**: Low-Medium

### Problem

Commands currently use `process.exit(1)` directly:

```typescript
catch (error) {
  spinner.fail('Failed to gather project information');
  console.error(chalk.red('\nâŒ Error:'), error.message);
  process.exit(1);  // âŒ Prevents testing and cleanup
}
```

**Issues**:
- Process termination can't be caught in tests
- Prevents cleanup handlers from running
- Makes CLI testing difficult
- Inconsistent error handling across commands

### Solution

**Architecture**:
1. Commands should **throw errors**, not exit
2. CLI entry point catches and handles all errors
3. Single error handler ensures consistency

**Implementation**:

**Step 1**: Update command functions to throw
```typescript
// src/commands/init.ts
export async function init(options) {
  try {
    // ... command logic
  } catch (error) {
    throw new Error(`Init failed: ${error.message}`);  // âœ… Throw instead
  }
}
```

**Step 2**: Add central error handler in CLI entry
```typescript
// bin/cortex-tms.js
async function main() {
  try {
    await program.parseAsync(process.argv);
  } catch (error) {
    console.error(chalk.red('\nâŒ Error:'), error.message);
    if (process.env.DEBUG) {
      console.error(error.stack);
    }
    process.exit(1);  // âœ… Only exit here
  }
}
```

**Step 3**: Update tests
```typescript
// tests/commands/init.test.ts
it('should throw error on invalid input', async () => {
  await expect(init({ scope: 'invalid' })).rejects.toThrow('Init failed');
});
```

### Files to Change

- `src/commands/*.ts` - All command files (init, validate, status, migrate, etc.)
- `bin/cortex-tms.js` - Add central error handler
- `tests/commands/*.test.ts` - Update tests to expect thrown errors

### Acceptance Criteria

- âœ… No `process.exit()` calls in command files
- âœ… All errors caught at CLI entry point
- âœ… Tests pass with new error handling
- âœ… Error messages remain user-friendly

### Source

Opus 4.5 Audit Section 3.4 - "Error Handling Inconsistency"

---

## [AUDIT-2] Add Zod Input Validation

**Priority**: ðŸ”´ HIGH
**Effort**: 2-3h
**Complexity**: Low

### Problem

CLI trusts user input without runtime validation:

```typescript
const answers = await runInitPrompts();
// No validation - trusts user typed valid values
await copyTemplates(templatesDir, cwd, answers);
```

**Issues**:
- Security risk at system boundary
- Type errors possible despite TypeScript
- Invalid configurations can break templates
- Poor user experience (errors happen late)

### Solution

Add Zod schemas for runtime validation at entry points.

**Implementation**:

**Step 1**: Install Zod
```bash
npm install zod
```

**Step 2**: Create validation schemas
```typescript
// src/utils/schemas.ts
import { z } from 'zod';

export const InitOptionsSchema = z.object({
  projectName: z.string().min(1).max(100).regex(/^[a-z0-9-]+$/i, {
    message: 'Project name must contain only letters, numbers, and hyphens'
  }),
  scope: z.enum(['nano', 'minimal', 'standard', 'enterprise']),
  overwrite: z.boolean().optional(),
  packageManager: z.enum(['npm', 'yarn', 'pnpm', 'bun']).optional(),
});

export const ConfigSchema = z.object({
  version: z.string().regex(/^\d+\.\d+\.\d+$/),
  scope: z.enum(['nano', 'minimal', 'standard', 'enterprise']),
  // ... other config fields
});

export type InitOptions = z.infer<typeof InitOptionsSchema>;
export type Config = z.infer<typeof ConfigSchema>;
```

**Step 3**: Validate at boundaries
```typescript
// src/commands/init.ts
import { InitOptionsSchema } from '../utils/schemas.js';

export async function init(options) {
  // Validate user input
  const validatedOptions = InitOptionsSchema.parse(options);

  // Now use validated data
  await copyTemplates(templatesDir, cwd, validatedOptions);
}
```

**Step 4**: Helpful error messages
```typescript
try {
  const validated = InitOptionsSchema.parse(userInput);
} catch (error) {
  if (error instanceof z.ZodError) {
    console.error(chalk.red('\nâŒ Invalid input:'));
    error.errors.forEach(err => {
      console.error(chalk.yellow(`  â€¢ ${err.path.join('.')}: ${err.message}`));
    });
    throw new Error('Validation failed');
  }
}
```

### Files to Change

- `package.json` - Add Zod dependency
- `src/utils/schemas.ts` - New file with all validation schemas
- `src/commands/init.ts` - Validate init prompts
- `src/utils/config.ts` - Validate config file loading
- `src/types/cli.ts` - Update types to use Zod inference
- `tests/utils/schemas.test.ts` - Test validation logic

### Acceptance Criteria

- âœ… All CLI inputs validated with Zod
- âœ… Config file validation on load
- âœ… Helpful error messages for invalid input
- âœ… Test coverage for validation schemas
- âœ… Types derived from Zod schemas (single source of truth)

### Source

Opus 4.5 Audit Section 3.5 - "Limited Input Validation"

---

## [AUDIT-3] Add Integration/E2E Tests

**Priority**: ðŸ”´ HIGH
**Effort**: 6-8h
**Complexity**: Medium

### Problem

Current tests focus on individual functions:
- Good unit test coverage (~74 tests)
- Missing end-to-end workflow tests
- No tests for command interactions
- Edge cases at boundaries not tested

**Gap**: Can't verify that commands work together correctly.

### Solution

Add integration/E2E tests that run actual CLI commands.

**Implementation**:

**Step 1**: Create test infrastructure
```typescript
// tests/e2e/helpers.ts
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import { mkdtemp, rm } from 'fs/promises';
import os from 'os';

const execAsync = promisify(exec);

export async function createTestProject() {
  const tmpDir = await mkdtemp(path.join(os.tmpdir(), 'cortex-e2e-'));
  return {
    dir: tmpDir,
    cleanup: async () => await rm(tmpDir, { recursive: true, force: true })
  };
}

export async function runCLI(args: string[], cwd: string) {
  const cliPath = path.join(__dirname, '../../bin/cortex-tms.js');
  const { stdout, stderr } = await execAsync(`node "${cliPath}" ${args.join(' ')}`, { cwd });
  return { stdout, stderr };
}
```

**Step 2**: Test complete workflows
```typescript
// tests/e2e/init-validate-workflow.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { createTestProject, runCLI } from './helpers.js';

describe('Init â†’ Validate Workflow', () => {
  let testProject;

  beforeEach(async () => {
    testProject = await createTestProject();
  });

  afterEach(async () => {
    await testProject.cleanup();
  });

  it('should initialize and validate successfully', async () => {
    // Step 1: Initialize
    const initResult = await runCLI(['init', '--scope', 'nano', '--yes'], testProject.dir);
    expect(initResult.stdout).toContain('Cortex TMS initialized');

    // Step 2: Validate
    const validateResult = await runCLI(['validate'], testProject.dir);
    expect(validateResult.stdout).toContain('Validation passed');
  });

  it('should detect missing files in validation', async () => {
    // Initialize but then delete a required file
    await runCLI(['init', '--scope', 'nano', '--yes'], testProject.dir);
    await rm(path.join(testProject.dir, 'NEXT-TASKS.md'));

    // Validation should fail
    await expect(runCLI(['validate'], testProject.dir)).rejects.toThrow();
  });
});
```

**Step 3**: Test error scenarios
```typescript
// tests/e2e/error-handling.test.ts
describe('Error Handling', () => {
  it('should handle invalid scope gracefully', async () => {
    const testProject = await createTestProject();

    await expect(
      runCLI(['init', '--scope', 'invalid'], testProject.dir)
    ).rejects.toThrow(/Invalid scope/);

    await testProject.cleanup();
  });

  it('should handle concurrent operations', async () => {
    const testProject = await createTestProject();

    // Run two inits simultaneously
    const [result1, result2] = await Promise.allSettled([
      runCLI(['init', '--scope', 'nano'], testProject.dir),
      runCLI(['init', '--scope', 'nano'], testProject.dir),
    ]);

    // One should succeed, one should fail or warn
    expect(result1.status === 'fulfilled' || result2.status === 'fulfilled').toBe(true);

    await testProject.cleanup();
  });
});
```

**Step 4**: Test migration workflows
```typescript
// tests/e2e/migration.test.ts
describe('Migration Workflow', () => {
  it('should migrate from v2.x to v3.x templates', async () => {
    const testProject = await createTestProject();

    // Set up v2.x templates
    await setupV2Templates(testProject.dir);

    // Run migration
    const result = await runCLI(['migrate', '--yes'], testProject.dir);
    expect(result.stdout).toContain('Migration complete');

    // Verify v3.x templates exist
    const filesExist = await checkV3Files(testProject.dir);
    expect(filesExist).toBe(true);

    await testProject.cleanup();
  });
});
```

### Files to Create

- `tests/e2e/` - New directory for E2E tests
- `tests/e2e/helpers.ts` - Test utilities
- `tests/e2e/init-validate-workflow.test.ts` - Main workflow tests
- `tests/e2e/error-handling.test.ts` - Error scenario tests
- `tests/e2e/migration.test.ts` - Migration workflow tests
- `tests/e2e/status-command.test.ts` - Status dashboard tests

### Acceptance Criteria

- âœ… E2E tests run actual CLI commands
- âœ… Test complete workflows (init â†’ validate â†’ status)
- âœ… Test error scenarios and edge cases
- âœ… Test command interactions
- âœ… Tests use temporary directories
- âœ… All tests clean up after themselves
- âœ… CI runs E2E tests alongside unit tests

### Source

Opus 4.5 Audit Section 4.3 - "Limited Integration Tests"

---

## [AUDIT-4] Add npm audit to CI

**Priority**: ðŸ”´ HIGH
**Effort**: 30 minutes
**Complexity**: Very Low

### Problem

No dependency vulnerability scanning in CI pipeline.

**Risk**: Supply chain attacks, vulnerable dependencies go unnoticed.

### Solution

Add `npm audit` step to CI workflow.

**Implementation**:

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Existing steps...
      - run: npm ci
      - run: npm test
      - run: npm run build

      # NEW: Add security audit
      - name: Security Audit
        run: pnpm audit --audit-level=high --prod
        continue-on-error: false  # Fail build on high/critical vulnerabilities
```

**Note**: Final implementation (v3.2) uses `pnpm audit --audit-level=high --prod` to:
- Check production dependencies only (`--prod`)
- Fail on high/critical vulnerabilities
- Match the pnpm-based tooling used throughout the project

See `.github/workflows/pr-checks.yml` and `docs/core/SECURITY.md` for the complete implementation.

### Files to Change

- `.github/workflows/ci.yml` (or main CI workflow)
- `README.md` - Document security practices

### Acceptance Criteria

- âœ… `npm audit` runs on every CI build
- âœ… Build fails on high/critical vulnerabilities
- âœ… Audit level configurable (currently: high)
- âœ… Clear output in CI logs

### Source

Opus 4.5 Audit Section 9 - "Security Considerations"

---

## [AUDIT-5] File Path Traversal Protection

**Priority**: ðŸŸ¡ MEDIUM
**Effort**: 1-2h
**Complexity**: Low

### Problem

Template paths are not validated against project root:

```typescript
// src/utils/templates.ts
const templatePath = path.join(templatesDir, userInput);  // âŒ No validation
await copyFile(templatePath, destPath);
```

**Risk**: Malicious template paths could read/write files outside project root.

**Example Attack**:
```typescript
userInput = "../../.env"  // Traverse out of templates dir
```

### Solution

Validate all paths resolve within expected boundaries.

**Implementation**:

```typescript
// src/utils/templates.ts
import path from 'path';

/**
 * Validates that a path resolves within an allowed parent directory
 * Prevents path traversal attacks
 */
export function validatePathSafety(userPath: string, allowedParent: string): string {
  // Resolve absolute paths
  const resolvedPath = path.resolve(allowedParent, userPath);
  const resolvedParent = path.resolve(allowedParent);

  // Check if resolved path starts with parent
  if (!resolvedPath.startsWith(resolvedParent + path.sep) && resolvedPath !== resolvedParent) {
    throw new Error(`Path traversal detected: ${userPath} is outside allowed directory`);
  }

  return resolvedPath;
}

// Usage in template copying
export async function copyTemplates(templatesDir, destDir, options) {
  const templates = await getTemplateList(options.scope);

  for (const template of templates) {
    // Validate source path
    const safeSrcPath = validatePathSafety(template, templatesDir);

    // Validate destination path
    const safeDstPath = validatePathSafety(template, destDir);

    await copyFile(safeSrcPath, safeDstPath);
  }
}
```

**Add tests**:

```typescript
// tests/utils/templates.test.ts
describe('validatePathSafety', () => {
  it('should allow paths within parent', () => {
    expect(validatePathSafety('subdir/file.md', '/parent')).toBe('/parent/subdir/file.md');
  });

  it('should reject path traversal attempts', () => {
    expect(() => validatePathSafety('../../etc/passwd', '/parent')).toThrow('Path traversal');
  });

  it('should reject absolute paths outside parent', () => {
    expect(() => validatePathSafety('/etc/passwd', '/parent')).toThrow('Path traversal');
  });

  it('should handle symbolic links safely', async () => {
    // Test that symlinks don't bypass validation
  });
});
```

### Files to Change

- `src/utils/templates.ts` - Add `validatePathSafety()` function
- `src/utils/templates.ts` - Use validation in `copyTemplates()`
- `tests/utils/templates.test.ts` - Add security tests

### Acceptance Criteria

- âœ… All template paths validated before use
- âœ… Path traversal attempts throw errors
- âœ… Tests cover malicious path scenarios
- âœ… No performance impact (validation is fast)

### Source

Opus 4.5 Audit Section 9 - "File path traversal"

---

## [AUDIT-6] Guardian API Key Redaction

**Priority**: ðŸŸ¡ MEDIUM
**Effort**: 1-2h
**Complexity**: Low

### Problem

Guardian uses BYOK (Bring Your Own Key) with API keys in environment variables. Risk of accidental exposure in logs or error output.

### Solution

Ensure API keys are never logged or exposed in error messages.

**Implementation**:

**Step 1**: Create redaction utility
```typescript
// src/utils/security.ts
/**
 * Redacts sensitive values from strings
 */
export function redactSensitive(text: string, patterns: RegExp[] = []): string {
  let redacted = text;

  // Default patterns for common API key formats
  const defaultPatterns = [
    /sk-[a-zA-Z0-9]{32,}/g,  // OpenAI keys
    /claude-[a-zA-Z0-9-]{32,}/g,  // Claude keys
    /Bearer [a-zA-Z0-9-_.]+/g,  // Bearer tokens
    /Authorization: [^\s]+/g,  // Auth headers
  ];

  [...defaultPatterns, ...patterns].forEach(pattern => {
    redacted = redacted.replace(pattern, '[REDACTED]');
  });

  return redacted;
}
```

**Step 2**: Wrap Guardian API calls
```typescript
// src/commands/guardian.ts or guardian-related files
import { redactSensitive } from '../utils/security.js';

export async function callGuardianAPI(prompt: string) {
  try {
    const apiKey = process.env.ANTHROPIC_API_KEY;
    // ... API call
  } catch (error) {
    // Redact before logging
    const safeMessage = redactSensitive(error.message);
    console.error(chalk.red('Guardian error:'), safeMessage);
    throw new Error(safeMessage);
  }
}
```

**Step 3**: Add tests
```typescript
// tests/utils/security.test.ts
describe('redactSensitive', () => {
  it('should redact OpenAI API keys', () => {
    const text = 'Error: Invalid key sk-abc123xyz456...';
    expect(redactSensitive(text)).toBe('Error: Invalid key [REDACTED]');
  });

  it('should redact Bearer tokens', () => {
    const text = 'Authorization: Bearer abc.def.ghi';
    expect(redactSensitive(text)).toBe('Authorization: [REDACTED]');
  });

  it('should not redact safe content', () => {
    const text = 'Error: File not found';
    expect(redactSensitive(text)).toBe('Error: File not found');
  });
});
```

**Step 4**: Audit all Guardian code
- Search for `console.log`, `console.error` in Guardian files
- Ensure all error messages go through redaction
- Check API call error handling

### Files to Change

- `src/utils/security.ts` - New file with redaction utilities
- Guardian-related files in `src/` - Wrap logging/errors
- `tests/utils/security.test.ts` - Test redaction

### Acceptance Criteria

- âœ… All Guardian errors redact API keys
- âœ… Redaction utility tested
- âœ… No API keys in console output
- âœ… Documentation on secure key handling

### Source

Opus 4.5 Audit Section 9 - "Guardian CLI (BYOK)"

---

## Testing Strategy

**Unit Tests**: Already good coverage
**Integration Tests**: NEW in this sprint (AUDIT-3)
**Security Tests**: NEW paths & redaction (AUDIT-5, AUDIT-6)

**CI Pipeline**:
```bash
pnpm test                           # Unit + integration tests
pnpm run lint                       # Code quality
pnpm audit --audit-level=high --prod  # NEW (AUDIT-4) - production deps only
pnpm run build                      # Verify TypeScript
```

**Note**: Final implementation uses pnpm consistently. See `.github/workflows/pr-checks.yml`.

---

## Success Metrics

After completing this sprint:
- âœ… All 6 audit tasks resolved
- âœ… Strict validation passes in CI
- âœ… Test coverage improves (integration tests added)
- âœ… Security posture strengthened (3 security tasks)
- âœ… Code quality improved (error handling, validation)

**Next Sprint**: Strategic features (Benchmark Suite, Pattern Marketplace)

---

**Note**: This is a WARM file. Read it when starting work on v3.1 tasks. For quick reference, see the task table in `NEXT-TASKS.md`.

<!-- @cortex-tms-version 3.1.0 -->
