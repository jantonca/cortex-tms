---
import { getCollection } from 'astro:content'
import type { GetStaticPaths } from 'astro'
import SimpleLayout from '../../layouts/SimpleLayout.astro'
import { Calendar, Clock, RefreshCw } from '@lucide/astro'
import SocialShare from '../../components/SocialShare.astro'
import RelatedPosts from '../../components/RelatedPosts.astro'
import TableOfContents from '../../components/TableOfContents.astro'
import '../../styles/blog-post-content.css'

export const getStaticPaths = (async () => {
  const blogEntries = await getCollection('blog', ({ data }) => {
    return import.meta.env.PROD ? data.draft !== true : true
  })

  return blogEntries.map((entry) => ({
    params: { slug: entry.slug },
    props: { entry },
  }))
}) satisfies GetStaticPaths

const { entry } = Astro.props
const { Content, headings } = await entry.render()

// Get all published blog posts for related posts and navigation
const allPosts = await getCollection('blog', ({ data }) => {
  return import.meta.env.PROD ? data.draft !== true : true
})

// Sort posts by date (newest first)
const sortedPosts = allPosts.sort(
  (a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf()
)

// Find current post index
const currentIndex = sortedPosts.findIndex((post) => post.slug === entry.slug)

// Get next and previous posts
const nextPost = currentIndex > 0 ? sortedPosts[currentIndex - 1] : null
const prevPost =
  currentIndex < sortedPosts.length - 1 ? sortedPosts[currentIndex + 1] : null

// Get related posts based on shared tags (limit to 3)
const relatedPosts = entry.data.tags
  ? sortedPosts
      .filter((post) => {
        // Exclude current post
        if (post.slug === entry.slug) return false
        // Check if post has any shared tags
        return (
          post.data.tags &&
          post.data.tags.some((tag) => entry.data.tags?.includes(tag))
        )
      })
      .slice(0, 3)
  : []

const formatDate = (date: Date) => {
  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }).format(date)
}

const calculateReadingTime = (text: string) => {
  const wordsPerMinute = 200
  const words = text.trim().split(/\s+/).length
  const minutes = Math.ceil(words / wordsPerMinute)
  return `${minutes} min read`
}

const readingTime = calculateReadingTime(entry.body)

// Construct Open Graph image URL
const ogImageUrl =
  entry.data.heroImage && entry.data.heroImage.trim()
    ? new URL(entry.data.heroImage, Astro.site).toString()
    : new URL('/og-image.png', Astro.site).toString()

// Construct canonical URL
const canonicalURL = new URL(`/blog/${entry.slug}/`, Astro.site).toString()
---

<SimpleLayout
  title={entry.data.title}
  description={entry.data.description}
  lang='en'
  dir='ltr'
>
  {/* Open Graph / Social Media Meta Tags */}
  <meta
    slot='head'
    property='og:type'
    content='article'
  />
  <meta
    slot='head'
    property='og:title'
    content={entry.data.title}
  />
  <meta
    slot='head'
    property='og:description'
    content={entry.data.description}
  />
  <meta
    slot='head'
    property='og:url'
    content={canonicalURL}
  />
  <meta
    slot='head'
    property='og:image'
    content={ogImageUrl}
  />
  <meta
    slot='head'
    property='og:image:width'
    content='1200'
  />
  <meta
    slot='head'
    property='og:image:height'
    content='630'
  />
  <meta
    slot='head'
    property='article:published_time'
    content={entry.data.pubDate.toISOString()}
  />
  {
    entry.data.updatedDate && (
      <meta
        slot='head'
        property='article:modified_time'
        content={entry.data.updatedDate.toISOString()}
      />
    )
  }
  {
    entry.data.author && (
      <meta
        slot='head'
        property='article:author'
        content={entry.data.author}
      />
    )
  }
  {
    entry.data.tags &&
      entry.data.tags.map((tag) => (
        <meta
          slot='head'
          property='article:tag'
          content={tag}
        />
      ))
  }

  {/* Twitter Card Meta Tags */}
  <meta
    slot='head'
    name='twitter:card'
    content='summary_large_image'
  />
  <meta
    slot='head'
    name='twitter:title'
    content={entry.data.title}
  />
  <meta
    slot='head'
    name='twitter:description'
    content={entry.data.description}
  />
  <meta
    slot='head'
    name='twitter:image'
    content={ogImageUrl}
  />

  {/* Canonical URL */}
  <link
    slot='head'
    rel='canonical'
    href={canonicalURL}
  />

  {/* Reading progress bar */}
  <div class='progress-bar-container'>
    <div class='progress-bar' id='reading-progress'></div>
  </div>

  {/* Ambient background gradients */}
  <div class='liquid-ambient-bg'></div>

  <div class='blog-container'>
    <article class='blog-post'>
    <header class='post-header'>
      {
        entry.data.tags && entry.data.tags.length > 0 && (
          <div class='post-tags'>
            {entry.data.tags.map((tag) => (
              <span class='tag'>{tag}</span>
            ))}
          </div>
        )
      }
      <h1>{entry.data.title}</h1>
      {
        entry.data.heroImage && (
          <figure class='hero-image'>
            <img
              src={entry.data.heroImage}
              alt={entry.data.heroAlt ?? entry.data.title}
              loading='lazy'
              decoding='async'
            />
          </figure>
        )
      }
      <div class='post-meta'>
        <img
          src='/logo.svg'
          alt='Cortex TMS'
          class='author-avatar'
        />
        <div class='meta-content'>
          <span class='author-text'>
            Words by <strong>{entry.data.author || 'Cortex TMS Team'}</strong>
          </span>
          <span class='meta-separator'>·</span>
          {
            entry.data.updatedDate && (
              <>
                <span class='meta-date'>
                  Updated on {formatDate(entry.data.updatedDate)}
                </span>
                <span class='meta-separator'>·</span>
              </>
            )
          }
          <span class='meta-date'>
            Published on {formatDate(entry.data.pubDate)}
          </span>
          <span class='meta-separator'>·</span>
          <span class='reading-time'>{readingTime}</span>
        </div>
      </div>

      <SocialShare
        url={canonicalURL}
        title={entry.data.title}
        description={entry.data.description}
      />
    </header>

    <div class='post-content'>
      <Content />
    </div>

    <footer class='post-footer'>
      <SocialShare
        url={canonicalURL}
        title={entry.data.title}
        description={entry.data.description}
      />
      <a
        href='/blog/'
        class='back-link'
        >← Back to Blog</a
      >
    </footer>
  </article>

  <aside class='toc-sidebar'>
    <TableOfContents headings={headings} />
  </aside>
</div>

  {relatedPosts.length > 0 && <RelatedPosts posts={relatedPosts} />}

  {
    (prevPost || nextPost) && (
      <nav class='post-navigation'>
        <div class='nav-container'>
          {prevPost ? (
            <a href={`/blog/${prevPost.slug}/`} class='nav-link prev-link'>
              <span class='nav-label'>← Previous Post</span>
              <span class='nav-title'>{prevPost.data.title}</span>
            </a>
          ) : (
            <div />
          )}
          {nextPost ? (
            <a href={`/blog/${nextPost.slug}/`} class='nav-link next-link'>
              <span class='nav-label'>Next Post →</span>
              <span class='nav-title'>{nextPost.data.title}</span>
            </a>
          ) : (
            <div />
          )}
        </div>
      </nav>
    )
  }

  <style>
    /* Smooth scroll behavior */
    html {
      scroll-behavior: smooth;
      scroll-padding-top: 6rem;
    }

    .progress-bar-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 3px;
      background: transparent;
      z-index: 9999;
    }

    .progress-bar {
      height: 100%;
      background: var(--sl-color-accent);
      width: 0%;
      transition: width 0.1s ease-out;
    }

    .blog-container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 0 2rem;
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 3rem;
      position: relative;
      z-index: 1;
    }

    .blog-post {
      max-width: 900px;
      padding: 2rem 3rem;
      position: relative;
      z-index: 1;
    }

    .toc-sidebar {
      position: relative;
    }

    .post-header {
      margin-bottom: 2rem;
      position: relative;
      z-index: 3;
    }

    .post-header h1 {
      font-size: 2.5rem;
      line-height: 1.2;
      margin: 0 0 2rem 0;
      color: var(--sl-color-text);
    }

    .hero-image {
      margin: 2rem 0;
      border-radius: 1rem;
      overflow: hidden;
    }

    .hero-image img {
      display: block;
      width: 100%;
      height: auto;
      object-fit: cover;
    }

    .post-meta {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 2rem;
      padding-top: 1.5rem;
      padding-bottom: 1.5rem;
      border-top: 1px solid var(--sl-color-gray-5);
      border-bottom: 1px solid var(--sl-color-gray-5);
      font-size: 0.9375rem;
      line-height: 1.5;
      color: var(--sl-color-gray-3);
      font-family: 'Noto Sans Mono', var(--sl-font-mono), monospace;
    }

    .author-avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid var(--sl-color-accent);
      background: #ffffff;
      padding: 2px;
      flex-shrink: 0;
    }

    .meta-content {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      line-height: 1.5;
    }

    .author-text {
      color: var(--sl-color-text);
      line-height: 1.5;
    }

    .author-text strong {
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .meta-separator {
      color: var(--sl-color-gray-4);
      font-size: 1.5rem;
      line-height: 1;
      font-weight: 700;
      display: flex;
      align-items: center;
    }

    .meta-date {
      color: var(--sl-color-gray-3);
      line-height: 1.5;
    }

    .reading-time {
      color: var(--sl-color-gray-3);
      line-height: 1.5;
    }

    .post-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .tag {
      padding: 0.25rem 0.75rem;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      font-size: 0.75rem;
      color: var(--sl-color-gray-3);
    }

    :root[data-theme='light'] .tag {
      background: rgba(0, 0, 0, 0.05);
    }

    .post-footer {
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 1px solid var(--sl-color-gray-5);
      position: relative;
      z-index: 3;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      color: var(--sl-color-accent);
      text-decoration: none;
      font-weight: 500;
      transition: color 0.2s;
    }

    .back-link:hover {
      color: var(--sl-color-accent-high);
    }

    .post-navigation {
      max-width: 900px;
      margin: 2rem auto;
      padding: 0 3rem;
      position: relative;
      z-index: 1;
    }

    .nav-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
    }

    .nav-link {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      text-decoration: none;
      padding: 1.5rem;
      border: 1px solid var(--sl-color-gray-5);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      transition: all 0.3s ease;
    }

    .nav-link:hover {
      transform: translateY(-2px);
      border-color: var(--sl-color-accent);
      background: rgba(255, 255, 255, 0.05);
    }

    .next-link {
      text-align: right;
    }

    .nav-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--sl-color-accent);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .nav-title {
      font-size: 1.125rem;
      font-weight: 500;
      color: var(--sl-color-text);
      line-height: 1.4;
    }

    :root[data-theme='light'] .nav-link {
      background: rgba(0, 0, 0, 0.02);
    }

    :root[data-theme='light'] .nav-link:hover {
      background: rgba(0, 0, 0, 0.04);
    }

    /* Hide TOC on tablet and below */
    @media (max-width: 1024px) {
      .blog-container {
        grid-template-columns: 1fr;
        gap: 0;
      }

      .toc-sidebar {
        display: none;
      }

      .blog-post {
        max-width: 900px;
        margin: 0 auto;
      }
    }

    @media (max-width: 768px) {
      .blog-container {
        padding: 0 1rem;
        margin: 1rem auto;
      }

      .blog-post {
        padding: 2rem 1.5rem;
      }

      .post-header h1 {
        font-size: 2rem;
      }

      .hero-image {
        margin: 1rem 0;
      }

      .post-content {
        font-size: 1rem;
      }

      .post-meta {
        font-size: 0.875rem;
      }

      .author-avatar {
        width: 40px;
        height: 40px;
      }

      .meta-content {
        font-size: 0.8125rem;
      }

      .post-navigation {
        padding: 0 1.5rem;
        margin: 1rem;
      }

      .nav-container {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .next-link {
        text-align: left;
      }
    }
  </style>

  <script>
    // Reading progress bar
    function updateProgressBar() {
      const progressBar = document.getElementById('reading-progress')
      if (!progressBar) return

      const windowHeight = window.innerHeight
      const documentHeight = document.documentElement.scrollHeight
      const scrollTop = window.scrollY || document.documentElement.scrollTop

      // Calculate scroll percentage
      const scrollableHeight = documentHeight - windowHeight
      const scrollPercentage = (scrollTop / scrollableHeight) * 100

      // Update progress bar width
      progressBar.style.width = `${Math.min(scrollPercentage, 100)}%`
    }

    // Update on scroll
    window.addEventListener('scroll', updateProgressBar, { passive: true })

    // Update on load
    window.addEventListener('load', updateProgressBar)

    // Update on resize
    window.addEventListener('resize', updateProgressBar, { passive: true })

    // Initial update
    updateProgressBar()
  </script>
</SimpleLayout>
